.. _udp:

UDP Component
=============

.. seo::
    :description: Instructions for setting up a UDP component on ESPHome
    :image: udp.svg
    :keywords: UDP

The purpose of this component is to allow ESPHome nodes to directly communicate with each over an IP network
without relying on Home Assistant. It permits the state of sensors and binary sensors to be broadcasted via UDP packets
to other nodes on the same LAN, or to specific IP addresses (which may be in a remote, but reachable, network.)

Nodes may be *providers* which broadcast sensor data, or *consumers* which receive sensor data from one or more
providers. A node may be both a provider and a consumer. Optional security is provided by one or more of:

- encryption using a shared secret key
- a rolling code
- a challenge-response (ping-pong) key

Wherever a provider name is required, this should be the node name configured in the ``esphome:`` block.

.. code-block:: yaml

    # Example configuration entry
    udp:
      update_interval: 5s
      encryption: "REPLACEME"
      rolling_code_enable: true
      binary_sensors:
        - binary_sensor_id1
      sensors:
        - sensor_id1
      providers:
        - name: some-device-name
          encryption: "REPLACEME with some key"

    sensor:
      - platform: udp
        provider: some-device-name
        id: local_sensor_id
        remote_id: some_sensor_id

    binary_sensor:
      - platform: udp
        provider: unencrypted-device
        id: other_binary_sensor_id  # also used as remote_id

Configuration variables:
------------------------

- **id** (*Optional*, :ref:`config-id`): Manually specify the ID used for code generation.
- **update_interval** (*Optional*, :ref:`config-time`): Interval between full broadcasts. Defaults to 15s.
- **port** (*Optional*, int): The destination UDP port number to use. Defaults to 18511.
- **addresses** (*Optional*, list of IPv4 addresses): One or more IP addresses to broadcast data to. Defaults to ``255.255.255.255``
  which is the local network broadcast address.
- **sensors** (*Optional*, list): A list of sensor IDs to be broadcasted.
- **binary_sensors** (*Optional*, list): A list of binary sensor IDs to be broadcasted.
- **encryption** (*Optional*, string): The encryption key to use when broadcasting. Default is no encryption. This may be
  any string, and will be hashed to form a 256 bit key.
- **rolling_code_enable** (*Optional*, boolean): Enables a rolling code to be included in all broadcasts. Requires ``encryption`` to be set. Defaults to ``false``.
- **ping_pong_enable** (*Optional*, boolean): When set, requires encrypted providers to include a *nonce* generated by this device in broadcasts. Defaults to ``false``.
- **providers** (*Optional*, list): A list of provider device names and optionally their secret encryption keys.

  - **name** (**Required**, string): The device name of the provider.
  - **encryption** (*Optional*, string): The provider's encryption key.

Reliability
-----------

UDP, like any other network protocol, does not provide a guarantee that data will be delivered, but unlike TCP it does not
even provide any indication whether data has been successfully delivered or not. When any of the configured sensors changes state,
the component will broadcast that sensor's state, but since this may not be received by a consumer, the UDP component
also broadcasts *all* sensor data on a timed schedule, set by ``update_interval``. Even this does not guarantee
delivery, but in practice unless the network has failed, updates will eventually be received, albeit possibly after
some delay.

Security
--------

By default there is no security - all data is transmitted in clear text on the network. This would be appropriate
for non-sensitive sensor data or perhaps on a fully secured wired network. For other cases the data can be encrypted
by providing an encryption key, which is shared between the provider and consumer.

The encryption used is `XXTEA <https://en.wikipedia.org/wiki/XXTEA>`_ which is fast and compact. Although XXTEA is known
to be susceptible to a chosen-plaintext attack, such an attack is not possible with this application, and it otherwise
has no published weaknesses [#f1]_. The implementation used here has been modified slightly to use a 256 bit key.

Encryption alone ensures that data cannot be read in transit and protects against spoofing of data, but does not protect
against replay attacks (where a threat actor records a transmission and replays it later, e.g. to repeat an action.)

A rolling code can be enabled which mitigates replay attacks - each transmission contains a 64 bit value which is
guaranteed to monotonically increase, so the consumer will reject any data received which contains a rolling code
already seen. The rolling code also ensures that the data in every packet is different, which makes brute-force
attacks on the encryption much more difficult. This is enabled in the provider configuration and adds minor overhead.

For further protection a ``ping-pong`` (or challenge-response) facility is available, which can be enabled in the
consumer configuration. The consumer periodically generates a 32 bit random number (a *nonce* aka "Number used Once")
and broadcasts it. Any provider receiving this nonce will include it in any future encrypted broadcasts. The consumer
expects to see its most recently transmitted nonce in any packets it receives, and will reject any that do not
contain it.

Use of the ping-pong feature will add to network traffic and the size of the transmitted packets (a single packet may
include up to 4 nonces from different devices) but provides a high level of protection against replay attacks. It does
require a 2-way network connection, and it only works on local networks because the consumer can only *broadcast* it to
all the providers.

.. note::

    The rolling code's top 32 bits is incremented and written to flash *once* at reboot on the provider node. 
    It's also incremented and written to flash when the counting, lower 32 bits overflows, which can only happen after
    a very long time. The consumer side does not store the received rolling codes in flash.

    When encryption is used, all the data is encrypted except the sender node name. This doesn't decrease the security
    level, because this information is available anyway in clear from the usual mdns broadcasts of the nodes. 

Configuration examples
----------------------

This example couples two light switches in two different devices, so that switching either one on or off will cause
the other to follow suit. In each case a template binary_sensor is used to mirror the switch state.

.. code-block:: yaml

    # Device 1
    esphome:
      name: device-1

    udp:
      binary_sensors:
        - relay1_sensor

    switch:
      - platform: gpio
        pin: GPIO6
        id: relay1
        name: "Device 1 switch"

    binary_sensor:
      - platform: template
        id: relay1_sensor
        lambda: "return id(relay1).state;"

      - platform: udp
        provider: device-2
        id: relay2_sensor
        on_press:
          switch.turn_on: relay1
        on_release:
          switch.turn_off: relay1


    # Device 2
    esphome:
      name: device-2

    udp:
      binary_sensors:
        - relay2_sensor

    switch:
      - platform: gpio
        pin: GPIO6
        id: relay2
        name: "Device 2 switch"

    binary_sensor:
      - platform: template
        id: relay2_sensor
        lambda: "return id(relay2).state;"

      - platform: udp
        provider: device-1
        id: relay1_sensor
        on_press:
          switch.turn_on: relay2
        on_release:
          switch.turn_off: relay2

The following example shows a device using encryption to read a sensor and two binary sensors from two different
devices, one with encryption and ping-pong and one without. It also rebroadcasts one of those binary sensors with its own
encryption and a rolling code to a remote host.

.. code-block:: yaml

    udp:
      update_interval: 60s
      addresses: ["10.87.135.110"]
      ping_pong_enable: true
      rolling_code_enable: true
      encryption: "Muddy Waters"
      binary_sensors:
        - tick_tock
      providers:
        - name: st7735s
          encryption: "Blind Willie Johnson"
        # - name: room-lights   # Not required here since no encryption

    binary_sensor:
      - platform: udp
        provider: st7735s
        id: tick_tock
      - platform: udp
        provider: room-lights
        id: relay1_sensor

    sensor:
      - platform: udp
        provider: st7735s
        id: wifi_signal_sensor

.. [#f1] As known in 2024.06.

See Also
--------

- :doc:`/components/binary_sensor/udp`
- :doc:`/components/sensor/udp`
- :ref:`automation`
- :apiref:`udp/udp_component.h`
- :ghedit:`Edit`
